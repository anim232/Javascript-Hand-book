### **Array() কনস্ট্রাকটর**

`Array()` কনস্ট্রাকটর একটি বিল্ট-ইন জাভাস্ক্রিপ্ট ফাংশন, যা নতুন একটি **Array (অ্যারে)** অবজেক্ট তৈরি করতে ব্যবহৃত হয়। আপনি এই কনস্ট্রাকটর ব্যবহার করে একটি অ্যারে তৈরি করতে পারেন, তার উপাদানগুলি উল্লেখ করে অথবা শুধু অ্যারের দৈর্ঘ্য (length) দিয়ে।

### **সিনট্যাক্স**

`Array()` কনস্ট্রাকটর ব্যবহার করার কয়েকটি পদ্ধতি রয়েছে:

1. **কোনো আর্গুমেন্ট না দিলে**:
   ```javascript
   new Array();  // একটি খালি অ্যারে তৈরি হবে
   Array();      // একই কাজ, কিন্তু `new` ছাড়া
   ```

2. **একটি আর্গুমেন্ট (এলিমেন্ট)**:
   ```javascript
   new Array(10);  // ১০টি "খালি" স্লটসহ একটি অ্যারে তৈরি হবে
   Array(10);      // একই কাজ, কিন্তু `new` ছাড়া
   ```

   এখানে, যদি আপনি **একটি সংখ্যা** (যেমন `10`) আর্গুমেন্ট হিসেবে দেন, তাহলে এটি একটি অ্যারে তৈরি করবে যার দৈর্ঘ্য হবে ১০। তবে, এখানে স্লটগুলো আসলে **খালি** থাকবে, অর্থাৎ সেখানে কোনো মান (value) থাকবে না, এবং সেগুলি `undefined` হবে না, বরং **খালি স্লট** থাকবে।

3. **একাধিক আর্গুমেন্ট (এলিমেন্ট1, এলিমেন্ট2, ..., এলিমেন্টN)**:
   ```javascript
   new Array(1, 2, 3);  // একটি অ্যারে তৈরি হবে: [1, 2, 3]
   Array(1, 2, 3);      // একই কাজ, কিন্তু `new` ছাড়া
   ```

   যখন আপনি একাধিক মান আর্গুমেন্ট হিসেবে দেন (যেমন `1, 2, 3`), তখন এটি একটি অ্যারে তৈরি করবে, যেটিতে ওই মানগুলো থাকবে: `[1, 2, 3]`।

4. **একটি একক আর্গুমেন্ট (arrayLength)**:
   ```javascript
   new Array(5);  // ৫টি খালি স্লটসহ একটি অ্যারে তৈরি হবে
   Array(5);      // একই কাজ, কিন্তু `new` ছাড়া
   ```

   এই ক্ষেত্রে, যদি আপনি **একটি পূর্ণসংখ্যা** (যেমন `5`) আর্গুমেন্ট হিসেবে দেন, তাহলে এটি একটি অ্যারে তৈরি করবে যার দৈর্ঘ্য হবে ৫, তবে **খালি স্লট** থাকবে।

---

### **কিছু বিশেষ ক্ষেত্র:**

1. **এটি যদি একটি সংখ্যার একক আর্গুমেন্ট হয়**:
   ```javascript
   let arr = new Array(3);
   console.log(arr);  // [ <3 empty slots> ]
   ```

   এখানে, `new Array(3)` একটি অ্যারে তৈরি করবে যার দৈর্ঘ্য ৩, কিন্তু এই অ্যারেটির মধ্যে কোনো মান থাকবে না, বরং **খালি স্লট** থাকবে।

2. **যদি একাধিক মান পাস করা হয়**:
   ```javascript
   let arr = new Array(1, 2, 3);
   console.log(arr);  // [1, 2, 3]
   ```

   এখানে, `new Array(1, 2, 3)` একটি অ্যারে তৈরি করবে যার মান হবে `[1, 2, 3]`।

---

### **ব্যতিক্রম (Exceptions)**

- **RangeError**: যদি আপনি একটি **একমাত্র পূর্ণসংখ্যা** পাস করেন (যেমন `new Array(1.5)` বা `new Array(-5)`), তবে একটি **RangeError** হতে পারে।
  - `arrayLength` এর মান **ইন্টিজার** হতে হবে এবং **0 এবং 2³² - ১** এর মধ্যে হতে হবে।

---

- `Array()` কনস্ট্রাকটর দিয়ে আপনি অ্যারে তৈরি করতে পারেন, তবে একটি বিশেষ বিষয় হল, যদি একটি মাত্র সংখ্যা পাস করেন (যেমন `new Array(10)`), তাহলে এটি ১০টি **খালি স্লট** তৈরি করবে।
- একাধিক মান দিলে (যেমন `new Array(1, 2, 3)`), এটি একটি সাধারণ অ্যারে তৈরি করবে যেখানে প্রতিটি মান অন্তর্ভুক্ত থাকবে।
- `Array()` কনস্ট্রাকটরকে `new` ছাড়াও ব্যবহার করা যেতে পারে, কারণ এটি একটি নতুন অ্যারে তৈরি করবে।


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
`Array` কনস্ট্রাকটর ব্যবহার করার প্রাসঙ্গিকতা এবং এর বাস্তব ব্যবহার (real use case) কিছু বিশেষ পরিস্থিতির মধ্যে দেখা যায়, যেখানে অ্যারে তৈরি করা প্রয়োজন এবং আপনি ডায়নামিকভাবে তার সাইজ বা উপাদানগুলো পরিচালনা করতে চান। যদিও সাধারণত অ্যারে তৈরি করার জন্য **array literal** (`[]`) ব্যবহার করা হয়, `Array` কনস্ট্রাকটরও কিছু নির্দিষ্ট পরিস্থিতিতে উপকারী হতে পারে।

এখন আসুন, বিস্তারিতভাবে দেখি কবে এবং কেন `Array` কনস্ট্রাকটর ব্যবহার করা যেতে পারে।

### **1. অ্যারের সাইজ ডায়নামিকভাবে নির্ধারণ করা (Dynamic Array Size)**

ধরা যাক, আপনি একটি অ্যারে তৈরি করতে চান যেটির সাইজ নির্ধারণ করবেন রানটাইমের সময় (run-time)। এতে অ্যারের দৈর্ঘ্য কিভাবে পরিবর্তিত হবে তা আগে থেকে জানা নেই। এমন ক্ষেত্রে `Array` কনস্ট্রাকটরের **সাইজ** প্যারামিটার ব্যবহার করা যেতে পারে।

#### উদাহরণ:

```javascript
let size = 10;  // সাইজটি ভ্যারিয়েবল বা ডাইনামিক হতে পারে
let myArray = new Array(size);  // একটি অ্যারে তৈরি হবে যার সাইজ 10
console.log(myArray);  // [ <10 empty slots> ]
```

এখানে, আপনি একটি অ্যারে তৈরি করেছেন যার সাইজ ১০। অ্যারের মান এখন খালি (empty slots) থাকবে, কিন্তু আপনি পরবর্তী সময়ে এই স্লটগুলোতে মান অ্যাসাইন (assign) করতে পারবেন।

#### বাস্তব উদাহরণ:
ধরা যাক, আপনার কাছে একটি ফর্মের ইনপুট আছে যেখানে ইউজার ১০টি উপাদান ইনপুট করতে পারবে। আপনি আগে থেকেই সাইজ জানেন, তাই আপনি `new Array(10)` ব্যবহার করে একটি অ্যারে তৈরি করতে পারেন।

### **2. যখন অ্যারে ফিল্ডের মান আগেই জানেন না**

যদি আপনার কাছে একটি অ্যারে থাকে এবং আপনি সেটা তৈরি করতে চান, কিন্তু আপনার কাছে আগের থেকেই অ্যারের উপাদানগুলির মান থাকে না (যেমনঃ ডাটা একটি API থেকে আসবে বা ইউজার ইনপুটের মাধ্যমে আসবে), তখন `Array` কনস্ট্রাকটর ব্যবহার করে আপনি অ্যারে তৈরি করতে পারেন, এরপর সেটিতে ডাটা পুশ (push) করতে পারেন।

#### উদাহরণ:

```javascript
let data = [1, 2, 3, 4];  // যেহেতু এখানে ডাটা আগে থেকে জানা আছে
let newArray = new Array(4);  // 4 সাইজের অ্যারে তৈরি করা হচ্ছে
newArray.push(...data);  // ডাটা পুশ করা হচ্ছে
console.log(newArray);  // [1, 2, 3, 4]
```

এখানে, আপনি একটি নতুন অ্যারে তৈরি করেছেন এবং সেই অ্যারেতে পুশ করেছেন পূর্বের ডাটা। যদিও এখানে `Array` কনস্ট্রাকটর ব্যবহার করা হয়েছে, তবে আপনি চাইলে `[]` (array literal) দিয়েও এটি করতে পারতেন, তবে এটি একটি উদাহরণ।

### **3. স্পার্স অ্যারে (Sparse Arrays) তৈরি করা**

`Array` কনস্ট্রাকটর ব্যবহার করে আপনি **স্পার্স অ্যারে** (sparse arrays) তৈরি করতে পারেন, যেখানে অ্যারে কিছু স্লটের জন্য খালি থাকে। এই ক্ষেত্রে, অ্যারের কিছু ইনডেক্সে `undefined` মান থাকবে, কিন্তু অ্যারেটির দৈর্ঘ্য সঠিক থাকবে। এটি তখন কার্যকরী হতে পারে যখন আপনি জানেন অ্যারের কিছু ইনডেক্সে কোনো মান থাকবে না, তবে সেগুলি স্পষ্টভাবে সেভ করা দরকার।

#### উদাহরণ:

```javascript
let sparseArray = new Array(5);  // ৫টি খালি স্লট সহ একটি অ্যারে তৈরি হবে
console.log(sparseArray);  // [ <5 empty slots> ]
```

এখানে, একটি অ্যারে তৈরি হয়েছে যার দৈর্ঘ্য ৫, কিন্তু স্লটগুলো খালি (empty slots) রয়েছে।

#### বাস্তব উদাহরণ:
ধরা যাক, আপনি একটি ৩৬০ ডিগ্রির মান তৈরি করতে চান যেখানে প্রতিটি ৫ ডিগ্রি পর পর একটি মান থাকবে, তবে কিছু ইনডেক্সে মান থাকবে না। আপনি স্পার্স অ্যারে ব্যবহার করতে পারেন যাতে এই ইনডেক্সগুলো খালি (undefined) থাকে।

### **4. অ্যারে এলিমেন্টের সংখ্যা জানলে অ্যারে তৈরি করা**

কখনো কখনো, যদি আপনি আগে থেকে জানেন যে আপনার অ্যারে কতগুলো উপাদান থাকবে, তখন `Array` কনস্ট্রাকটর ব্যবহার করে আপনি অ্যারেটির সাইজ নির্দিষ্ট করতে পারেন।

#### উদাহরণ:

```javascript
let arr = new Array(3);  // একটি অ্যারে তৈরি হবে যার সাইজ ৩
arr[0] = 'A';
arr[1] = 'B';
arr[2] = 'C';
console.log(arr);  // ['A', 'B', 'C']
```

এখানে, `new Array(3)` দিয়ে একটি অ্যারে তৈরি করা হয়েছে এবং পরে ৩টি মান অ্যাসাইন করা হয়েছে।

---

### **কেন `Array` কনস্ট্রাকটর ব্যবহার করবেন?**

1. **ডায়নামিক অ্যারে তৈরি করা**: যদি আপনার অ্যারের সাইজ নির্দিষ্ট না থাকে, তবে `Array()` কনস্ট্রাকটর ব্যবহার করে অ্যারের সাইজ সহজে নির্ধারণ করা যায়।
2. **স্পার্স অ্যারে তৈরি করা**: কিছু ক্ষেত্রে অ্যারে তৈরি করার পর কিছু স্লট খালি রাখতে হতে পারে, যেখানে আপনি বিশেষভাবে `Array` কনস্ট্রাকটর ব্যবহার করতে পারেন।
3. **লম্বা অ্যারে সহজে তৈরি করা**: বড় অ্যারে তৈরি করতে `Array()` কনস্ট্রাকটর ব্যবহার করলে কোড আরও পরিষ্কার এবং পাঠযোগ্য হতে পারে, বিশেষত যখন আপনি জানেন অ্যারেটির সাইজ আগে থেকেই নির্দিষ্ট হবে।

---

### **কখন `Array` কনস্ট্রাকটর ব্যবহার না করবেন?**

1. **যখন এলিমেন্টগুলো আগে থেকেই জানা থাকে**: যদি আপনি অ্যারে তৈরি করতে চান এবং এর মধ্যে কিছু মান (elements) আগে থেকেই জানেন, তাহলে **array literal** (`[]`) ব্যবহার করা আরও সহজ এবং পরিষ্কার হবে।
   - উদাহরণ: `let arr = [1, 2, 3];`
2. **অতিরিক্ত জটিলতা**: `Array` কনস্ট্রাকটর কিছু পরিস্থিতিতে জটিল হতে পারে, যেমন একক আর্গুমেন্ট হিসেবে একটি সংখ্যা দিলে স্পার্স অ্যারে তৈরি হবে, যা বিভ্রান্তির সৃষ্টি করতে পারে। সাধারণত আপনি যদি মানগুলির তালিকা জানেন, তবে `[]` ব্যবহার করা সহজ এবং নিরাপদ।

---


`Array` কনস্ট্রাকটরের ব্যবহার বিশেষ পরিস্থিতিতে সহায়ক হতে পারে, যেমন অ্যারের সাইজ আগে থেকে জানলে বা স্পার্স অ্যারে তৈরি করতে চাইলে। তবে সাধারণত অ্যারে লিটারাল ([]) ব্যবহার করাই বেশি প্রস্তাবিত, কারণ এটি সহজ এবং ব্যবহারযোগ্য।


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 **complex real-world use case**  `Array` কনস্ট্রাকটর এবং অ্যারে সম্পর্কিত অন্যান্য জাভাস্ক্রিপ্ট ফিচারগুলি ব্যবহৃত হবে। এই উদাহরণটি একটি প্রকল্পে ব্যবহারযোগ্য হতে পারে, যেমন: **ডাইনামিক ডাটা ফিল্টারিং এবং প্রক্রিয়াকরণ**।

### **Use Case: ই-কমার্স প্ল্যাটফর্মে প্রোডাক্ট ফিল্টারিং এবং সোর্টিং**

ধরা যাক, একটি ই-কমার্স সাইট রয়েছে যেখানে বিভিন্ন প্রোডাক্ট আছে (যেমন পোশাক, ইলেকট্রনিক্স, গ্যাজেটস ইত্যাদি)। ব্যবহারকারী বিভিন্ন ফিল্টার অ্যাপ্লাই করতে পারে (যেমন প্রোডাক্টের রেটিং, দাম, ব্র্যান্ড ইত্যাদি) এবং সেগুলিকে আলাদা আলাদা ক্রাইটেরিয়া অনুযায়ী সোর্ট করতে পারে।

এখানে, আমরা `Array` কনস্ট্রাকটর ব্যবহার করব প্রোডাক্ট ডাটা পরিচালনা করার জন্য এবং ইউজার ফিল্টার ও সোর্ট অপশনগুলোর ভিত্তিতে অ্যারেগুলো তৈরি করব। পাশাপাশি, জাভাস্ক্রিপ্টের বিভিন্ন অ্যারে মেথডের ব্যবহার দেখানো হবে।

### **প্রকল্পের লক্ষ্য:**
- প্রোডাক্টের লিস্ট থেকে **ডাইনামিক ফিল্টারিং**।
- ইউজারের সিলেকশনের ভিত্তিতে প্রোডাক্টগুলিকে **সোর্ট করা**।
- যদি কোনো ফিল্টার না থাকে, তবে সঠিক অ্যারে তৈরি করা।

### **ধাপ ১: ডাটা তৈরি করা (Array Constructor ব্যবহার)**

প্রথমে, একটি অ্যারে তৈরি করা হবে যার মধ্যে বিভিন্ন প্রোডাক্টের ডাটা থাকবে। এখানে `Array()` কনস্ট্রাকটর ব্যবহার করে প্রোডাক্টের ডাটা পূর্ণাঙ্গভাবে সাজানো হবে।

```javascript
// প্রোডাক্টের ডাটা - সাধারণত এই ডাটা সার্ভার থেকে আসবে
let products = new Array(
  { id: 1, name: "Shirt", category: "Clothing", price: 20, rating: 4.5, brand: "BrandA" },
  { id: 2, name: "Phone", category: "Electronics", price: 300, rating: 4.7, brand: "BrandB" },
  { id: 3, name: "Jeans", category: "Clothing", price: 50, rating: 4.0, brand: "BrandA" },
  { id: 4, name: "Laptop", category: "Electronics", price: 700, rating: 4.8, brand: "BrandC" },
  { id: 5, name: "Jacket", category: "Clothing", price: 80, rating: 4.6, brand: "BrandB" },
  { id: 6, name: "Headphones", category: "Electronics", price: 120, rating: 4.3, brand: "BrandC" }
);

// প্রোডাক্টের ডাটা দেখানো
console.log(products);
```

### **ধাপ ২: ফিল্টারিং ফাংশন তৈরি করা**

এখন, আমরা ফিল্টারিং ফাংশন তৈরি করব যা ইউজারের বিভিন্ন ফিল্টারের উপর ভিত্তি করে প্রোডাক্টের অ্যারে পরিবর্তন করবে। ফিল্টারিং অপশনগুলো হতে পারে: **ক্যাটেগরি**, **দাম**, **রেটিং**, **ব্র্যান্ড**।

```javascript
// ফিল্টারিং ফাংশন
function filterProducts(products, filters) {
  let filteredProducts = new Array(...products);  // ডাটা কপি করা (Shallow copy)

  if (filters.category) {
    filteredProducts = filteredProducts.filter(product => product.category === filters.category);
  }

  if (filters.minPrice) {
    filteredProducts = filteredProducts.filter(product => product.price >= filters.minPrice);
  }

  if (filters.maxPrice) {
    filteredProducts = filteredProducts.filter(product => product.price <= filters.maxPrice);
  }

  if (filters.rating) {
    filteredProducts = filteredProducts.filter(product => product.rating >= filters.rating);
  }

  if (filters.brand) {
    filteredProducts = filteredProducts.filter(product => product.brand === filters.brand);
  }

  return filteredProducts;
}

// ফিল্টার অপশন
let filters = {
  category: "Clothing",
  minPrice: 30,
  maxPrice: 100,
  rating: 4.5
};

// ফিল্টারড প্রোডাক্টস
let filteredProducts = filterProducts(products, filters);
console.log(filteredProducts);
```

এখানে:
- আমরা `filterProducts()` ফাংশন ব্যবহার করেছি যা প্রোডাক্টগুলিকে ইউজারের দেয়া ফিল্টার অনুযায়ী ফিল্টার করে।
- `new Array(...products)` ব্যবহার করা হয়েছে একটি **shallow copy** তৈরির জন্য, যাতে মূল ডাটাতে পরিবর্তন না হয়।

### **ধাপ ৩: সোর্টিং ফাংশন তৈরি করা**

এখন, ফিল্টার করা প্রোডাক্টগুলো সোর্ট করা হবে। স্লটগুলিকে **দাম** বা **রেটিং** অনুসারে সোর্ট করা হতে পারে। এখানে আমরা দাম (price) বা রেটিং (rating) অনুযায়ী সোর্ট করার একটি ফাংশন তৈরি করব।

```javascript
// সোর্টিং ফাংশন
function sortProducts(products, sortBy, order = "asc") {
  let sortedProducts = new Array(...products); // shallow copy

  if (sortBy === "price") {
    sortedProducts.sort((a, b) => {
      return order === "asc" ? a.price - b.price : b.price - a.price;
    });
  } else if (sortBy === "rating") {
    sortedProducts.sort((a, b) => {
      return order === "asc" ? a.rating - b.rating : b.rating - a.rating;
    });
  }

  return sortedProducts;
}

// সোর্ট অপশন
let sortedProducts = sortProducts(filteredProducts, "price", "desc");
console.log(sortedProducts);
```

এখানে:
- `sortProducts()` ফাংশন `products` অ্যারে সাইজে একটি **shallow copy** তৈরি করে, তারপর `price` বা `rating` অনুসারে সেগুলিকে সোর্ট করে।
- আমরা `order` প্যারামিটার ব্যবহার করেছি যাতে ইউজার চাইলে **ascending** (ASC) বা **descending** (DESC) অর্ডারে সেগুলো সোর্ট করতে পারে।

### **ধাপ ৪: একসাথে ফিল্টারিং ও সোর্টিং**

এখন, আমরা ফিল্টার ও সোর্ট একসাথে করব। প্রথমে ফিল্টার, তারপর সোর্ট করার প্রক্রিয়া হবে।

```javascript
// ফিল্টার ও সোর্ট একসাথে
function filterAndSortProducts(products, filters, sortBy, order) {
  let filtered = filterProducts(products, filters); // ফিল্টারিং
  return sortProducts(filtered, sortBy, order);     // সোর্টিং
}

// ফিল্টার ও সোর্ট একসাথে ব্যবহার
let finalProducts = filterAndSortProducts(products, filters, "price", "asc");
console.log(finalProducts);
```

এখানে:
- প্রথমে `filterProducts()` ফাংশন ব্যবহার করে ইউজারের দেয়া ফিল্টার অনুযায়ী প্রোডাক্টগুলো ফিল্টার করা হয়।
- তারপর `sortProducts()` ফাংশন ব্যবহার করে সেগুলিকে ইউজারের দেয়া সোর্টিং ক্রাইটেরিয়ার (এবং অর্ডার) অনুসারে সজ্জিত করা হয়।

এটি ফিল্টার এবং সোর্টের প্রক্রিয়াকে একটি বাস্তব প্রকল্পের মতো সাজানো হয়েছে যেখানে `Array` কনস্ট্রাকটর এবং অন্যান্য অ্যারে মেথড ব্যবহার করা হয়েছে।

এটি একটি **ই-কমার্স প্রোডাক্ট ফিল্টারিং এবং সোর্টিং** সিস্টেমের উদাহরণ, যেখানে:
- **`Array()` কনস্ট্রাকটর** ব্যবহার করে অ্যারে তৈরি করা হয়েছে এবং সাইজ নিয়ন্ত্রণ করা হয়েছে।
- **`filter()` এবং `sort()`** মেথড দিয়ে ডাটা ফিল্টার এবং সোর্ট করা হয়েছে।
- **ফাংশনাল প্রোগ্রামিং** এর ধারণা প্রয়োগ করা হয়েছে যাতে একাধিক ধাপে ডাটা প্রক্রিয়াকরণ করা যায়।


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 **`Array` কনস্ট্রাকটর** ব্যবহার করা হবে একাধিক **অ্যারে ম্যানিপুলেশন**, **অবজেক্ট স্টোরেজ**, এবং **ডাইনামিক ডাটা প্রসেসিং** এর মধ্যে।

### **Use Case: ডাইনামিক টাস্ক ম্যানেজমেন্ট সিস্টেম**

ধরা যাক, আপনি একটি **টাস্ক ম্যানেজমেন্ট সিস্টেম** তৈরি করছেন যেখানে ইউজাররা তাদের কাজের লিস্ট পরিচালনা করতে পারে। এখানে, আমরা বিভিন্ন **টাস্ক** এর আইটেম, তাদের **স্ট্যাটাস**, **ডেডলাইন**, **প্রাইওরিটি**, এবং **ইনভলভড ইউজার** সহ একটি **অ্যারে অবজেক্ট** ম্যানেজ করব। ইউজার চাইলে তাদের টাস্কগুলি ফিল্টার করতে, সোর্ট করতে, এবং নতুন টাস্ক যোগ করতে পারবে।

### **প্রকল্পের লক্ষ্য:**
- টাস্কের আইটেম তৈরি করা এবং তার মধ্যে ডাইনামিক তথ্য (যেমন ডেডলাইন, স্ট্যাটাস, প্রাইওরিটি) সংরক্ষণ করা।
- টাস্কের অবস্থান পরিবর্তন করতে, সেগুলিকে সোর্ট করতে, ফিল্টার করতে সহায়তা করা।
- টাস্ক সম্পাদনা বা মুছে ফেলা।
- ডাইনামিকভাবে টাস্কের সংখ্যা পরিবর্তন করা।

### **ধাপ ১: টাস্ক ডাটা তৈরি করা**

প্রথমে, আমরা টাস্কগুলির একটি ডাটা লিস্ট তৈরি করব, যেখানে প্রতিটি টাস্কের জন্য কিছু প্রোপার্টি থাকবে যেমন `id`, `name`, `status`, `deadline`, `priority` ইত্যাদি।

```javascript
// টাস্কের ডাটা তৈরি
let tasks = new Array(
  { id: 1, name: "Complete Project", status: "Pending", deadline: "2025-01-15", priority: 1, assignedTo: "Alice" },
  { id: 2, name: "Write Report", status: "Completed", deadline: "2025-01-10", priority: 2, assignedTo: "Bob" },
  { id: 3, name: "Fix Bugs", status: "In Progress", deadline: "2025-01-20", priority: 1, assignedTo: "Charlie" },
  { id: 4, name: "Meeting with Client", status: "Completed", deadline: "2025-01-05", priority: 3, assignedTo: "Alice" },
  { id: 5, name: "Design UI", status: "Pending", deadline: "2025-01-18", priority: 2, assignedTo: "Bob" }
);

// টাস্কের ডাটা দেখানো
console.log(tasks);
```

### **ধাপ ২: টাস্ক ফিল্টার করা**

এখন, আমাদের একটি ফিল্টার ফাংশন তৈরি করতে হবে যা ইউজারদের নির্দিষ্ট **স্ট্যাটাস**, **ডেডলাইন** অথবা **প্রাইওরিটি** অনুযায়ী টাস্ক ফিল্টার করতে দেয়।

```javascript
// টাস্ক ফিল্টার করার ফাংশন
function filterTasks(tasks, filters) {
  let filteredTasks = new Array(...tasks);  // শ্যালো কপি তৈরি করা

  if (filters.status) {
    filteredTasks = filteredTasks.filter(task => task.status === filters.status);
  }

  if (filters.minPriority) {
    filteredTasks = filteredTasks.filter(task => task.priority >= filters.minPriority);
  }

  if (filters.deadline) {
    filteredTasks = filteredTasks.filter(task => task.deadline <= filters.deadline);
  }

  return filteredTasks;
}

// ফিল্টার অপশন
let filters = {
  status: "Pending",
  minPriority: 2,
  deadline: "2025-01-18"
};

// ফিল্টারড টাস্ক দেখানো
let filteredTasks = filterTasks(tasks, filters);
console.log(filteredTasks);
```

এখানে:
- আমরা `filterTasks()` ফাংশন তৈরি করেছি যা টাস্কগুলিকে ইউজারের দেয়া ফিল্টার অনুযায়ী ফিল্টার করবে।
- `new Array(...tasks)` ব্যবহার করা হয়েছে যাতে আমরা মূল ডাটাকে পরিবর্তন না করি, বরং একটি নতুন অ্যারে তৈরি করি।

### **ধাপ ৩: টাস্ক সোর্টিং**

এখন, আমরা সorting ফাংশন তৈরি করব যাতে টাস্কগুলো `priority` অথবা `deadline` অনুযায়ী সজ্জিত (sorted) করা যায়।

```javascript
// টাস্ক সোর্ট করার ফাংশন
function sortTasks(tasks, sortBy, order = "asc") {
  let sortedTasks = new Array(...tasks);  // শ্যালো কপি তৈরি করা

  if (sortBy === "priority") {
    sortedTasks.sort((a, b) => {
      return order === "asc" ? a.priority - b.priority : b.priority - a.priority;
    });
  } else if (sortBy === "deadline") {
    sortedTasks.sort((a, b) => {
      return order === "asc" ? new Date(a.deadline) - new Date(b.deadline) : new Date(b.deadline) - new Date(a.deadline);
    });
  }

  return sortedTasks;
}

// সোর্ট অপশন
let sortedTasks = sortTasks(filteredTasks, "deadline", "desc");
console.log(sortedTasks);
```

এখানে:
- `sortTasks()` ফাংশন একটি নতুন অ্যারে তৈরি করে এবং তারপর **priority** বা **deadline** অনুসারে টাস্কগুলো সজ্জিত করে।

### **ধাপ ৪: নতুন টাস্ক যোগ করা এবং মুছে ফেলা**

এখন, আমাদের দরকার এমন ফাংশন যা ইউজারের দেয়া ডাটা দিয়ে নতুন টাস্ক অ্যারে তে যোগ করবে অথবা নির্দিষ্ট টাস্ক মুছে ফেলবে।

```javascript
// নতুন টাস্ক যোগ করার ফাংশন
function addTask(tasks, newTask) {
  tasks.push(newTask);  // নতুন টাস্ক যোগ করা
  return tasks;
}

// টাস্ক মুছে ফেলার ফাংশন
function removeTask(tasks, taskId) {
  let index = tasks.findIndex(task => task.id === taskId);
  if (index !== -1) {
    tasks.splice(index, 1);  // টাস্ক মুছে ফেলা
  }
  return tasks;
}

// নতুন টাস্ক যোগ করা
let newTask = { id: 6, name: "Test Application", status: "Pending", deadline: "2025-01-25", priority: 1, assignedTo: "David" };
tasks = addTask(tasks, newTask);
console.log(tasks);

// টাস্ক মুছে ফেলা
tasks = removeTask(tasks, 2);  // id: 2 এর টাস্ক মুছে ফেলা
console.log(tasks);
```

এখানে:
- `addTask()` ফাংশন নতুন একটি টাস্ক অ্যারে তে যোগ করে।
- `removeTask()` ফাংশন টাস্কের `id` দিয়ে টাস্ক মুছে ফেলে।

### **ধাপ ৫: একসাথে ফিল্টার, সোর্ট এবং অ্যাড/রিমুভ**

এখন, আমরা চাইলে একসাথে ফিল্টার, সোর্ট, টাস্ক অ্যাড ও রিমুভ করতে পারব। এখানে সবগুলো অপারেশন একত্রে করা হয়েছে।

```javascript
// টাস্ক ফিল্টার, সোর্ট, এবং অ্যাড/রিমুভ একসাথে
function manageTasks(tasks, filters, sortBy, order, newTask, taskIdToRemove) {
  // ফিল্টার
  let filteredTasks = filterTasks(tasks, filters);

  // সোর্ট
  let sortedTasks = sortTasks(filteredTasks, sortBy, order);

  // নতুন টাস্ক যোগ করা
  if (newTask) {
    sortedTasks = addTask(sortedTasks, newTask);
  }

  // টাস্ক মুছে ফেলা
  if (taskIdToRemove) {
    sortedTasks = removeTask(sortedTasks, taskIdToRemove);
  }

  return sortedTasks;
}

// ব্যবহারের উদাহরণ
let finalTasks = manageTasks(tasks, filters, "priority", "asc", newTask, 4);
console.log(finalTasks);
```

এখানে:
- `manageTasks()` ফাংশন সবগুলো অপারেশন একত্রে করতে সক্ষম। ফিল্টার, সোর্ট, নতুন টাস্ক যোগ করা এবং টাস্ক মুছে ফেলা একসাথে করা হয়েছে।

### **ফাইনাল আউটপুট:**

ফাইনাল আউটপুট হবে, ফিল্টার করা, সোর্ট করা এবং টাস্ক যোগ ও মুছে ফেলার পর নতুন টাস্কের তালিকা।
x
এখানে দেখানো হয়েছে কিভাবে **`Array` কনস্ট্রাকটর** ব্যবহার করা যেতে পারে একটি **জটিল প্রকল্পে** (complex project use case) যেখানে:
1. ডাইনামিক ডাটা ফিল্টারিং
2. sorting
3. টাস্ক যোগ ও মুছে ফেলা
4. একাধিক অ্যারে অপারেশন



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
